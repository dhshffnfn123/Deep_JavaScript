/* -------------------------------------------------------------------------- */
/*                            원시 값과 객체의 비교                             */
/* -------------------------------------------------------------------------- */

// 자바스크립트가 제공하는 7가지 타입은 크게 원시 타입과 객체 타입으로 구분할 수 있다.
// 원시 타입과 객체타입은 크게 세가지 측면에서 다르다.

// 1. 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 이에 비해 객체 타입의 값, 즉 객체는 변경 가능한 값이다.

// 2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.

// 3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(pass by value)이라고 한다.
//    이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(pass by reference)라고 한다.

//?/* ---------------------------------- 원시 값 ---------------------------------- */
// 원시타입의 값, 즉 원시 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값으로서 변경할 수 없다.)
// 변경이 불가능 하다는 것은 변수가 아니라 값에 대한 설명이다.
// 원시 값이 변경 불가능 하다는 것은 원시값을 변경하는 것이 불가능한 것이지 변수의 값을 변경하는 것이 불가능한 것이 아니다.
// 변수는 언제든지 재할당을 통해 변수 값을 변경(엄밀히는 교체이다.)할 수 있다.

// 상수는 재할당이 금지된 변수를 말한다.
// 변수는 언제든지 재할당이 가능하지만 상수는 불가능하다. 상수는 재할당이 금지된 변수일 뿐이다.
const o = {};
o.a = 1;
console.log(o); // { a: 1 }
// 원시 값은 어떤일이 있어도 불변한다. 따라서 원시 값의 특성은 데이터의 신뢰성을 보장한다.

// 변수를 재할당 할 경우 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한다. 이 때 변수가 참조하던 메모리 공간의 주소가 바뀐다.(원시 값은 변경이 불가능하기 때문)
// 이러한 특성을 '불변성'이라고 한다.
// 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

//?/* -------------------------------- 문자열과 불변성 -------------------------------- */
// 문자열은 0개 이상의 문자로 이뤄진 집합을 말하며, 1개의 문자는 2바이트의 메모리 공간에 저장된다.
// 따라서 문자열은 몇개의 문자로 이뤄졌냐에 따라 필요한 메모리 공간의 크기가 결정된다.
// 숫자 값은 1도, 10000000도 동일한 8바이트가 필요하지만 문자열은 문자당 2바이트가 필요하다.
var str1 = "";
var str2 = "Hello";

// C언어는 하나의 문자를 위한 데이터 타입 (char)만 있을 뿐 문자열타입은 존재하지 않는다.
// C에서는 문자열을 문자의 배열로 처리하고 자바는 문자열을 String객체로 처리한다.
// 자바스크립트는 개발자의 편의를 위해 원시타입인 문자열 타입을 제공한다.
// 자바스크립트의 문자열은 원시타입이며, 변경 불가능하다.
var str = "Hello";
str = "world"; // 변수가 가리키는 것만이 바뀌었을 뿐이다.

// 문자열은 유사 배열 객체이면서 이터러블 이므로 배열과 유사하게 각 문자에 접근할 수 있다.
// 문자열은 배열처럼 인덱스를 통해 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for문으로 순회할 수 있다.
var str = "string";
console.log(str[0]); // s
// 원시 값인 문자열이 객체처럼 동작한다.
console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스로 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이 때 에러가 발생하지 않는다.
var str = "string";
str[0] = "S";
console.log(str); // string
// 이러한 특성은 데이터의 신뢰성을 보장한다.

//?/* -------------------------------- 값에 의한 전달 -------------------------------- */
// 변수의 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달된다. 이를 '값에 의한 전달'이라한다.
var score = 80;
var copy = score;
console.log(score); // 80
console.log(copy); // 80
score = 100;
console.log(score); // 100
console.log(copy); // 80

// score와 copy 변수는 숫자 값 80을 갖는다는 점에서 동일하지만 score변수와 copy변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.
var score = 80;
// copy 변수에는 score 변수의 값 80이 '복사'되어 할당된다. (복사된 값이기 때문에 별개의 값이다.)
var copy = score;
console.log(score, copy); // 80 80
console.log(score === copy); // true

// '값에 의한 전달'과 '참조에 의한 전달' 말고도 '공유에 의한 전달(pass by sharing)'이라고 표현하는 경우도 있다.
// 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다.
// 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기 때문이다.

// 값의 의한 전달도 값을 전달하는 것이 아니라 메모리 주소를 전달하는 것이다.
// 이 때  전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

// 변수에 원시 값을 갖는 변수를 할당하면 두 변수는 다른 메모리 공간에 저장된 별개의 값이 되어
// 어느 한쪽이 재할당 되더라도 서로 간섭할 수는 없다.

//?/* ----------------------------------- 객체 ----------------------------------- */
// 객체는 프로퍼티의 개수가 정해져 있지 않고, 동적으로 추가되고 삭제할 수 있다.
// 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다.

//?/* -------------------------------- 변경 가능한 값 -------------------------------- */
// 객체는 변경 가능한 값이다.
var person = {
  name: "Lee",
};
// 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다.
// 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다.
// 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.
var person = {
  name: "Lee",
};
console.log(person); // {name: Lee}
// 원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다.
// 하지만 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.
person.name = "Kim";
person.address = "Seoul";
console.log(person); // {name: "Kim" address: "Seoul"}

// 객체는 여러개의 식별자가 객체를 공유할 수 있다는 구조적 단점이 있다.

// 얕은 복사와 깊은 복사
// 얕은 복사는 한단계까지만 복사하는 것이고, 깊은 복사는 객체에 중첩되어있는 객체까지 복사하는 것이다.

const o = { x: { y: 1 } };
// 얕은 복사
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true
// lodash의 cloneDeep을 이용한 깊은 복사
const _ = require("lodash");
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false

//?/* -------------------------------- 참조에 의한 전달 ------------------------------- */
var person = {
  name: "Lee",
};
// 참조 값을 복사 (얕은 복사)
var copy = person; // copy와 person은 동일한 참조 값을 갖는다.

// 두개의 식별자가 하나의 객체를 공유한다.
// 어느 한쪽에서 객체를 변경하면 둘 다 영향을 받는다.

copy.name = "kim";
person.address = "Seoul";
console.log(copy); // {name: kim , address: Seoul}
console.log(person); // {name: kim , address: Seoul}

// 자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만 존재한다.
var person1 = {
  name: "Lee",
};
var person2 = {
  name: "Lee",
};
console.log(person1 === person2); // false
console.log(person1.name === person2.name); // true
